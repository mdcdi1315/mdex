
## About block state providers

In vanilla Minecraft, block state providers are objects used by the game 
to define the block states to place on the world during generation.

Block states are objects (not blocks however) that 
define how their associated block behaves and looks like when placed on the world.

Their individual states are set through properties, defining the data that such states can hold.

For example, a placed chest block facing east is controlled by the block state property 
named `facing`, and for our example, it has the value `east`.

Other blocks have other or more than one property, making them having many different appearances.

However, block states do not always relate with how the block is rendered but also how it behaves.

For example, a sculk shrieker block has the `can_summon` block state property, which it can control whether
the in question shrieker can spawn or not a warden in the Deep Dark.

You can discover the individual properties that a block has at a given moment through the F3 debug screen.

Block states are needed so to define how the block generated by a feature should be placed on the world.
Thus, it is critical to understand the block state providers provided by the mod, and how each one behaves.

### The simple state provider

A simple state provider could be this:

~~~JSON
{
    "type": "mdex:simple_state_provider",
    "state": {
        "Name": "minecraft:stone_bricks"
    }
}
~~~

If you copy-paste it in a feature that requires it, it will place stone bricks.

If you notice above the `Name` field defines the block to use. 
There is also and an optional field named `Properties`, 
which it does define the values of the block state's properties,
that I explained above.

Here is another example defining a simple block state provider, along with its properties:

~~~JSON
{
    "type": "mdex:simple_state_provider",
    "state": {
        "Name": "minecraft:chest",
        "Properties": {
            "facing": "east"
        }
    }
}
~~~

Thus, any feature that uses this will place chests, and their latch will be facing at east.

### The weighted state provider

Weighted state providers are conveniently used in cases where you want the feature to look like random, such as floors
or other kinds of generation, such as flower generation.

The states are selected by weights, that are values that specify their selection proportionally to other entries in the list.
If two states have the same weight, they have both the same probability to be selected.

This provider does not provide a single block state to fill wherever the feature wants to with one block; it uses multiple block states instead.

This is a good example of that:
~~~JSON
{
    "type": "mdex:weighted_state_provider",
    "entries": [
        {
            "weight": 10,
            "data": {
                "Name": "minecraft:chest",
                "Properties": {
                    "facing": "west"
                }
            }
        }, 
        {
            "weight": 20,
            "data": {
                "Name": "minecraft:chest", 
                "Properties": {
                    "facing": "east"
                }
            }
        }
    ]
}
~~~

For 1.5.0 versions of the mod and later the above example becomes:
~~~JSON
{
    "type": "mdex:weighted_state_provider",
    "entries": [
        {
            "weight": 10,
			"Name": "minecraft:chest",
			"Properties": {
				"facing": "west"
			}
        }, 
        {
            "weight": 20,
			"Name": "minecraft:chest",
			"Properties": {
				"facing": "east"
			}
        }
    ]
}
~~~

When the feature will want to generate something using this provider,
the provider will roll a random value and the random value will be mapped to
one of the list's entries. That entry will be returned instead.

In this example, assume that a block state has been requested.

The entry returned will not always be the same but most of the chests will be facing east, but there will be and some others facing west, though.

### The noise-based state provider

Apart from the weighted state provider, there are and noise-related state providers
that can help you to achieve controlled randomization over which block states are selected,
by just modifying the noise values.

These providers do also allow to load their noise data from an external noise file,
allowing for a hierarchical organization of your noise data (or for reusability, why not?)

There are multiple variants of noise-based state providers,
but I will only describe the most basic one.

Here is an example of a noise-based state provider:
~~~JSON
{
    "type": "mdex:noise_provider",
    "noise": {
        "firstOctave": -1,
        "amplitudes": [ -1, -1 , 3 , 8 ]
    },
    "seed": 23765782356,
    "scale": 3,
    "states": [
        {
            "Name": "minecraft:stone_bricks"
        }, 
        {
            "Name": "minecraft:chest",
            "Properties": {
                "facing": "east"
            }
        }, 
        {
            "Name": "minecraft:crafting_table"
        }
    ]
}
~~~

Notice the difference in how the states are defined: no weights are required since the noise is our randomizer in this case.

Try also to experiment with the noise values to achieve the desired result; you can also use [this visualization tool](https://misode.github.io/worldgen/noise) to see when a block from the list will be placed or not.

### The rule test-based state provider

This state provider provides a similar syntax to how the ore feature targets are defined.

Useful for cases where you want to apply specific blocks in specific stone types.

For this state provider to work, however, it requires and a default, 'fallback' block state to use if all the rule tests defined have failed.

Here is an example of using it:

~~~JSON
{
    "type": "mdex:rule_test_based_provider",
	"fallback_state": {
        "Name": "minecraft:stone"
    },
    "targets": [
		{
            "state": {
                "Name": "minecraft:granite"
            },
            "target": {
				"predicate_type": "minecraft:tag_match",
				"tag": "minecraft:stone_ore_replaceables"
            }
        },
		{
            "state": {
                "Name": "mdex:granite"
            },
            "target": {
				"predicate_type": "minecraft:tag_match",
				"tag": "mdcdi1315_md:hardstone_ore_replaceables"
            }
        }
    ]
}
~~~

### Advanced block state providers

There are also and some other providers that can manipulate block states on their own.

These are documented below.

### The rotated block provider

This special kind of block provider is a simple state provider that can place pillar blocks on the X , Y or Z axis of the 3D space.

You also do normally define any other properties you need to through the `Properties` object.

For the provider to work, the block must support the `axis` property. If the property is not defined, the object referencing this block state provider will fail compilation.

A prime example of such blocks are the log blocks.

The example below demonstrates that:
~~~JSON
{
    "type": "mdex:rotated_block_provider",
    "state": {
        "Name": "minecraft:oak_log"
    }
}
~~~

### The randomized int state provider

This state provider can take an integer property (a property taking specific integer values) and 
randomize the selected values of the selected property.

Instead of specifying the base block state as a reference point, 
this provider takes another block state provider of the above (or itself pointing to another property!)

A prime example of a block using integer properties are the water cauldrons, specifying the water level that they can have to.

~~~JSON
{
    "type": "mdex:randomized_int_state_provider",
    "source": {
        "type": "mdex:simple_state_provider",
        "state": {
            "Name": "minecraft:water_cauldron"
        }
    },
    "property": "level",
    "values": {
        "type": "minecraft:uniform",
        "value": {
            "min_inclusive": 0,
            "max_inclusive": 3
        }
    }
}
~~~

The above state provider will return water cauldrons that they have a water level from 0 to 3 inclusive.
